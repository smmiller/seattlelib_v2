""" Justin Cappos -- substitute for a few python math routines"""

def math_ceil(x):
  xint = int(x)
  
  # if x is positive and not equal to itself truncated then we should add 1
  if x > 0 and x != xint:
    xint = xint + 1

  # I return a float because math.ceil does
  return float(xint)



def math_floor(x):
  xint = int(x)
  
  # if x is negative and not equal to itself truncated then we should subtract 1
  if x < 0 and x != xint:
    xint = xint - 1

  # I return a float because math.ceil does
  return float(xint)



math_e = 2.7182818284590451
math_pi = 3.1415926535897931

# Algorithm from logN.py on
# http://en.literateprograms.org/Logarithm_Function_(Python)#chunk
# MIT license
#
# hmm, math_log(4.5,4)      == 1.0849625007211561
# Python's math.log(4.5,4)  == 1.0849625007211563
# I'll assume this is okay.
def math_log(X, base=math_e, epsilon=1e-16):
  # JMC: The domain of the log function is {n | n > 0)
  if X <= 0:
    raise ValueError, "log function domain error"

  # log is logarithm function with the default base of e
  integer = 0
  if X < 1 and base < 1:
    # BUG: the cmath implementation can handle smaller numbers...
    raise ValueError, "math domain error"
  while X < 1:
    integer -= 1
    X *= base
  while X >= base:
    integer += 1
    X /= base
  partial = 0.5               # partial = 1/2 
  X *= X                      # We perform a squaring
  decimal = 0.0
  while partial > epsilon:
    if X >= base:             # If X >= base then a_k is 1 
      decimal += partial      # Insert partial to the front of the list
      X = X / base            # Since a_k is 1, we divide the number by the base
    partial *= 0.5            # partial = partial / 2
    X *= X                    # We perform the squaring again
  return (integer + decimal)


# SMM:
# Mostly a helper for taylor approximation of cos,
# but we might as well give it to the caller.
#
# Note: Results in a RuntimeError for x >= 1000
#
#
def math_factorial(x):
  if x == 0:
    return 1
  else:
    return x * math_factorial(x-1)



# SMM:
# We can compute cos with a taylor series approximation.
# At the magic number of 11 terms, we get a value very
# close to python.
#
# math_cos(2.1) == -0.5048461045998466 
# math.cos(2.1) == -0.5048461045998576
#
#
TERMS = 11

def math_cos(x):
  taylorsum = 0
  for n in range(TERMS):
    taylorsum += (-1)**n * (x**(2*n) / math_factorial(2*n))
  return taylorsum



# SMM:
# Don't need another taylor series when
# we have the trig identity for sin & cos.
#
#
def math_sin(x):
  return (1 - math_cos(x)**2)**0.5



# SMM:
# We (or the caller) could do math_sin(x) / math_cos(x),
# but that would be computationally inefficient. Better
# to calculate math_cos(x) once.
#
#
def math_tan(x):
  cosx = math_cos(x)
  return (1 - cosx**2)**0.5 / cosx


